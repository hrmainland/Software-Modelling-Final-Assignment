Index: src/thrones/game/GameOfThrones.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package thrones.game;\n\n// Oh_Heaven.java\nimport ch.aplu.jcardgame.*;\nimport ch.aplu.jgamegrid.*;\n\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.util.*;\nimport java.util.stream.Collectors;\n\n@SuppressWarnings(\"serial\")\npublic class GameOfThrones extends CardGame {\n\n    static public int seed;\n    static Random random;\n    private static int watchingTime;\n    private final String version = \"1.0\";\n    public final int nbPlayers = 4;\n    public final int nbStartCards = 9;\n    public final int nbPlays = 6;\n    public final int nbRounds = 3;\n    private Deck deck = new Deck(Suit.values(), Rank.values(), \"cover\");\n    private final GameRenderer gameRenderer = new GameRenderer(this);\n    private final BattleHandler battleHandler = new BattleHandler();\n    private Hand[] hands;\n    private Hand[] piles;\n    private final String[] playerTeams = { \"[Players 0 & 2]\", \"[Players 1 & 3]\"};\n    private int nextStartingPlayer = random.nextInt(nbPlayers);\n    private int[] scores = new int[nbPlayers];\n    // private boolean[] humanPlayers = { true, false, false, false};\n    private boolean[] humanPlayers = { false, false, false, false};\n    private Optional<Card> selected;\n    private final int NON_SELECTION_VALUE = -1;\n    private int selectedPileIndex = NON_SELECTION_VALUE;\n    private final int UNDEFINED_INDEX = -1;\n    private final int ATTACK_RANK_INDEX = 0;\n    private final int DEFENCE_RANK_INDEX = 1;\n\n    private PileCalculator pileCalculator;\n\n    private static ArrayList<Player> playerList = new ArrayList<>();\n\n    enum GoTSuit { CHARACTER, DEFENCE, ATTACK, MAGIC }\n\n    public enum Suit {\n        SPADES(GoTSuit.DEFENCE),\n        HEARTS(GoTSuit.CHARACTER),\n        DIAMONDS(GoTSuit.MAGIC),\n        CLUBS(GoTSuit.ATTACK);\n\n        Suit(GoTSuit gotsuit) {\n            this.gotsuit = gotsuit;\n        }\n        private final GoTSuit gotsuit;\n\n        public boolean isDefence(){ return gotsuit == GoTSuit.DEFENCE; }\n\n        public boolean isAttack(){ return gotsuit == GoTSuit.ATTACK; }\n\n        public boolean isCharacter(){ return gotsuit == GoTSuit.CHARACTER; }\n\n        public boolean isMagic(){ return gotsuit == GoTSuit.MAGIC; }\n    }\n\n    public enum Rank {\n        // Reverse order of rank importance (see rankGreater() below)\n        // Order of cards is tied to card images\n        ACE(1),\n        KING(10),\n        QUEEN(10),\n        JACK(10),\n        TEN(10),\n        NINE(9),\n        EIGHT(8),\n        SEVEN(7),\n        SIX(6),\n        FIVE(5),\n        FOUR(4),\n        THREE(3),\n        TWO(2);\n        Rank(int rankValue) {\n            this.rankValue = rankValue;\n        }\n        private final int rankValue;\n        public int getRankValue() {\n            return rankValue;\n        }\n    }\n\n    /*\n    Canonical String representations of Suit, Rank, Card, and Hand\n    */\n    String canonical(Suit s) { return s.toString().substring(0, 1); }\n    String canonical(Rank r) {\n        switch (r) {\n            case ACE: case KING: case QUEEN: case JACK: case TEN:\n                return r.toString().substring(0, 1);\n            default:\n                return String.valueOf(r.getRankValue());\n        }\n    }\n    String canonical(Card c) { return canonical((Rank) c.getRank()) + canonical((Suit) c.getSuit()); }\n    String canonical(Hand h) {\n        return \"[\" + h.getCardList().stream().map(this::canonical).collect(Collectors.joining(\",\")) + \"]\";\n    }\n\n    // Draws a random card from the Hand, based on a random number generator\n    public static Card randomCard(Hand hand) {\n        assert !hand.isEmpty() : \" random card from empty hand.\";\n        int x = random.nextInt(hand.getNumberOfCards());\n        return hand.get(x);\n    }\n\n    /*\n     Deals out the entire pack of 52 cards without shuffling, removing aces,\n     and ensuring each player gets 3 heart cards and 9 non-hearts\n     */\n    private void dealingOut(Hand[] hands, int nbPlayers, int nbCardsPerPlayer) {\n        Hand pack = deck.toHand(false);\n        assert pack.getNumberOfCards() == 52 : \" Starting pack is not 52 cards.\";\n        // Remove 4 Aces\n        List<Card> aceCards = pack.getCardsWithRank(Rank.ACE);\n        for (Card card : aceCards) {\n            card.removeFromHand(false);\n        }\n        assert pack.getNumberOfCards() == 48 : \" Pack without aces is not 48 cards.\";\n        // Give each player 3 heart cards\n        for (int i = 0; i < nbPlayers; i++) {\n            for (int j = 0; j < 3; j++) {\n                List<Card> heartCards = pack.getCardsWithSuit(Suit.HEARTS);\n                int x = random.nextInt(heartCards.size());\n                Card randomCard = heartCards.get(x);\n                randomCard.removeFromHand(false);\n                hands[i].insert(randomCard, false);\n            }\n        }\n        assert pack.getNumberOfCards() == 36 : \" Pack without aces and hearts is not 36 cards.\";\n        // Give each player 9 of the remaining cards\n        for (int i = 0; i < nbCardsPerPlayer; i++) {\n            for (int j = 0; j < nbPlayers; j++) {\n                assert !pack.isEmpty() : \" Pack has prematurely run out of cards.\";\n                Card dealt = randomCard(pack);\n                dealt.removeFromHand(false);\n                hands[j].insert(dealt, false);\n            }\n        }\n        for (int j = 0; j < nbPlayers; j++) {\n            assert hands[j].getNumberOfCards() == 12 : \" Hand does not have twelve cards.\";\n        }\n    }\n\n    private void initScore() {\n        for (int i = 0; i < nbPlayers; i++) {\n            scores[i] = 0;\n            gameRenderer.renderScores(i);\n        }\n        gameRenderer.renderPileText();\n    }\n\n    private void setupGame() {\n        hands = new Hand[nbPlayers];\n        pileCalculator = new PileCalculator();\n        for (int i = 0; i < nbPlayers; i++) {\n            hands[i] = new Hand(deck);\n        }\n        dealingOut(hands, nbPlayers, nbStartCards);\n\n        for (int i = 0; i < nbPlayers; i++) {\n            hands[i].sort(Hand.SortType.SUITPRIORITY, true);\n            System.out.println(\"hands[\" + i + \"]: \" + canonical(hands[i]));\n        }\n\n        for (final Hand currentHand : hands) {\n            // Set up human player for interaction\n            currentHand.addCardListener(new CardAdapter() {\n                public void leftDoubleClicked(Card card) {\n                    selected = Optional.of(card);\n                    currentHand.setTouchEnabled(false);\n                }\n                public void rightClicked(Card card) {\n                    selected = Optional.empty(); // Don't care which card we right-clicked for player to pass\n                    currentHand.setTouchEnabled(false);\n                }\n            });\n        }\n        // graphics\n        gameRenderer.renderhandLayouts(nbPlayers, hands);\n        // End graphics\n    }\n\n    private void pickACorrectSuit(int playerIndex, boolean isCharacter) {\n        Hand currentHand = hands[playerIndex];\n        List<Card> shortListCards = new ArrayList<>();\n        for (int i = 0; i < currentHand.getCardList().size(); i++) {\n            Card card = currentHand.getCardList().get(i);\n            Suit suit = (Suit) card.getSuit();\n            if (suit.isCharacter() == isCharacter) {\n                shortListCards.add(card);\n            }\n        }\n        if (shortListCards.isEmpty() || !isCharacter && random.nextInt(3) == 0) {\n            selected = Optional.empty();\n        } else {\n            selected = Optional.of(shortListCards.get(random.nextInt(shortListCards.size())));\n        }\n    }\n\n    private void selectRandomPile() {\n        selectedPileIndex = random.nextInt(2);\n    }\n\n    private void waitForCorrectSuit(int playerIndex, boolean isCharacter) {\n        if (hands[playerIndex].isEmpty()) {\n            selected = Optional.empty();\n        } else {\n            selected = null;\n            hands[playerIndex].setTouchEnabled(true);\n            do {\n                if (selected == null) {\n                    delay(100);\n                    continue;\n                }\n                Suit suit = selected.isPresent() ? (Suit) selected.get().getSuit() : null;\n                if (isCharacter && suit != null && suit.isCharacter() ||         // If we want character, can't pass and suit must be right\n                        !isCharacter && (suit == null || !suit.isCharacter())) { // If we don't want character, can pass or suit must not be character\n                    // if (suit != null && suit.isCharacter() == isCharacter) {\n                    break;\n                } else {\n                    selected = null;\n                    hands[playerIndex].setTouchEnabled(true);\n                }\n                delay(100);\n            } while (true);\n        }\n    }\n\n    private void waitForPileSelection() {\n        selectedPileIndex = NON_SELECTION_VALUE;\n        for (Hand pile : piles) {\n            pile.setTouchEnabled(true);\n        }\n        while(selectedPileIndex == NON_SELECTION_VALUE) {\n            delay(100);\n        }\n        for (Hand pile : piles) {\n            pile.setTouchEnabled(false);\n        }\n    }\n\n    private int getPlayerIndex(int index) {\n        return index % nbPlayers;\n    }\n\n    private void resetPile() {\n        if (piles != null) {\n            for (Hand pile : piles) {\n                pile.removeAll(true);\n            }\n        }\n        piles = new Hand[2];\n        for (int i = 0; i < 2; i++) {\n            piles[i] = new Hand(deck);\n            gameRenderer.renderPile(piles[i], i);\n            final Hand currentPile = piles[i];\n            final int pileIndex = i;\n            piles[i].addCardListener(new CardAdapter() {\n                public void leftClicked(Card card) {\n                    selectedPileIndex = pileIndex;\n                    currentPile.setTouchEnabled(false);\n                }\n            });\n        }\n\n        rankUpdater(piles);\n    }\n\n    private void executeAPlay() {\n        resetPile();\n\n        nextStartingPlayer = getPlayerIndex(nextStartingPlayer);\n        if (hands[nextStartingPlayer].getNumberOfCardsWithSuit(Suit.HEARTS) == 0)\n            nextStartingPlayer = getPlayerIndex(nextStartingPlayer + 1);\n        assert hands[nextStartingPlayer].getNumberOfCardsWithSuit(Suit.HEARTS) != 0 : \" Starting player has no hearts.\";\n\n        // 1: play the first 2 hearts\n        for (int i = 0; i < 2; i++) {\n            int playerIndex = getPlayerIndex(nextStartingPlayer + i);\n            updatePlayers();\n\n            setStatusText(\"Player \" + playerIndex + \" select a Heart card to play\");\n\n            // currentPlayer chooses card, pile based on their in-class rules\n            Player currentPlayer = playerList.get(playerIndex);\n            int pileIndex = currentPlayer.getPile();\n            selected = currentPlayer.getBestCard();\n\n            // Print console message\n            assert selected.isPresent() : \" Pass returned on selection of character.\";\n            System.out.println(\"Player \" + playerIndex + \" plays \" + canonical(selected.get()) + \" on pile \" + pileIndex);\n\n            // Handle drawing / transfer logic\n            selected.get().setVerso(false);\n            selected.get().transfer(piles[pileIndex], true); // transfer to pile (includes graphic effect)\n            rankUpdater(piles);\n\n            // Update the state of every player to reflect move change\n            updatePlayers();\n\n        }\n\n        // 2: play the remaining nbPlayers * nbRounds - 2\n        int remainingTurns = nbPlayers * nbRounds - 2;\n        int nextPlayer = nextStartingPlayer + 2;\n\n        while(remainingTurns > 0) {\n            nextPlayer = getPlayerIndex(nextPlayer);\n            setStatusText(\"Player\" + nextPlayer + \" select a non-Heart card to play.\");\n\n            // currentPlayer chooses card, pile based on their in-class rules\n            Player currentPlayer = playerList.get(nextPlayer);\n            selected = currentPlayer.getBestCard();\n\n            if (selected.isPresent()) {\n                selectedPileIndex = currentPlayer.getPile();\n                setStatusText(\"Selected: \" + canonical(selected.get()) + \". Player\" + nextPlayer + \" select a pile to play the card.\");\n                System.out.println(\"Player \" + nextPlayer + \" plays \" + canonical(selected.get()) + \" on pile \" + selectedPileIndex);\n                selected.get().setVerso(false);\n                selected.get().transfer(piles[selectedPileIndex], true); // transfer to pile (includes graphic effect)\n                rankUpdater(piles);\n\n            } else {\n                setStatusText(\"Pass.\");\n            }\n            // Update the state of every player to reflect move change\n            updatePlayers();\n\n            nextPlayer++;\n            remainingTurns--;\n        }\n\n        // 3: calculate winning & update scores for players\n        rankUpdater(piles);\n        int[] pile0Ranks = pileCalculator.calculatePileRanks(0, piles);\n        int[] pile1Ranks = pileCalculator.calculatePileRanks(1, piles);\n        gameRenderer.printStartBattleInfo(pile0Ranks, pile1Ranks,piles, ATTACK_RANK_INDEX, DEFENCE_RANK_INDEX);\n        scores = battleHandler.battle(pile0Ranks, pile1Ranks, scores, piles);\n        gameRenderer.reRenderScore(scores, playerTeams, nbPlayers);\n        gameRenderer.setStatusText(battleHandler.getCharacter0Result(), battleHandler.getCharacter1Result());\n\n        // 5: discarded all cards on the piles\n        nextStartingPlayer += 1;\n        delay(watchingTime);\n    }\n\n    private void updatePlayers(){\n        for (int j=0; j<nbPlayers; j++) {\n            playerList.get(j).updateState(hands[j], piles);\n        }\n    }\n\n    public void rankUpdater(Hand[] piles){\n        ArrayList<int[]> bothRanks;\n        bothRanks = pileCalculator.updatePileRanks(piles);\n        for (int j = 0; j < piles.length; j++){\n            int[] ranks = bothRanks.get(j);\n            gameRenderer.updatePileRankState(j, ranks[ATTACK_RANK_INDEX], ranks[DEFENCE_RANK_INDEX], playerTeams);\n        }\n    }\n    public GameOfThrones() {\n        super(700, 700, 30);\n\n        setTitle(\"Game of Thrones (V\" + version + \") Constructed for UofM SWEN30006 with JGameGrid (www.aplu.ch)\");\n        setStatusText(\"Initializing...\");\n        initScore();\n\n        setupGame();\n        for (int i = 0; i < nbPlays; i++) {\n            executeAPlay();\n            gameRenderer.reRenderScore(scores, playerTeams, nbPlayers);\n        }\n\n        String text;\n        if (scores[0] > scores[1]) {\n            text = \"Players 0 and 2 won.\";\n        } else if (scores[0] == scores[1]) {\n            text = \"All players drew.\";\n        } else {\n            text = \"Players 1 and 3 won.\";\n        }\n        System.out.println(\"Result: \" + text);\n        setStatusText(text);\n\n        refresh();\n    }\n\n    public static void main(String[] args) throws FileNotFoundException {\n        //System.out.println(\"Working Directory = \" + System.getProperty(\"user.dir\"));\n        Properties properties;\n\n        if (args == null || args.length == 0) {\n            properties = PropertiesLoader.loadPropertiesFile(\"properties/onlysmart.properties\");\n        } else {\n            properties = PropertiesLoader.loadPropertiesFile(args[0]);\n        }\n\n        initialiseGameProperties(properties);\n\n        System.out.println(\"Seed = \" + seed);\n        GameOfThrones.random = new Random(seed);\n        new GameOfThrones();\n    }\n\n    private static void initialiseGameProperties(Properties properties) {\n        PlayerFactory playerFactory = new PlayerFactory();\n\n        String seedProp = properties.getProperty(\"seed\");  //Seed property\n        if (seedProp != null) { // Use property seed\n            seed = Integer.parseInt(seedProp);\n        } else { // and no property\n            seed = new Random().nextInt(); // so randomise\n        }\n\n        String watchingTimeProp = properties.getProperty(\"watchingTime\");\n        if (watchingTimeProp != null) { // Use property watching time\n            watchingTime = Integer.parseInt(watchingTimeProp);\n        } else { // and no property\n            watchingTime = 5000; // so use default\n        }\n\n        for (int i=0; i<4; i++) {\n            String playerType = properties.getProperty(\"players.\" + i);\n            playerList.add(playerFactory.getPlayer(playerType, i));\n        }\n    }\n}\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/thrones/game/GameOfThrones.java b/src/thrones/game/GameOfThrones.java
--- a/src/thrones/game/GameOfThrones.java	(revision f60b451f93982f613df0b4dd79b33b4c8de814cb)
+++ b/src/thrones/game/GameOfThrones.java	(date 1667032293414)
@@ -289,11 +289,11 @@
         for (int i = 0; i < 2; i++) {
             int playerIndex = getPlayerIndex(nextStartingPlayer + i);
             updatePlayers();
-
             setStatusText("Player " + playerIndex + " select a Heart card to play");
 
             // currentPlayer chooses card, pile based on their in-class rules
             Player currentPlayer = playerList.get(playerIndex);
+            currentPlayer.updateState(hands[playerIndex], piles);
             int pileIndex = currentPlayer.getPile();
             selected = currentPlayer.getBestCard();
 
@@ -307,7 +307,9 @@
             rankUpdater(piles);
 
             // Update the state of every player to reflect move change
-            updatePlayers();
+            for (int j=0; j<nbPlayers; j++) {
+                playerList.get(j).updateState(hands[j], piles);
+            }
 
         }
 
@@ -318,25 +320,37 @@
         while(remainingTurns > 0) {
             nextPlayer = getPlayerIndex(nextPlayer);
             setStatusText("Player" + nextPlayer + " select a non-Heart card to play.");
+            /*if (humanPlayers[nextPlayer]) {
+                waitForCorrectSuit(nextPlayer, false);
+            } else {
+                pickACorrectSuit(nextPlayer, false);
+            }*/
 
             // currentPlayer chooses card, pile based on their in-class rules
             Player currentPlayer = playerList.get(nextPlayer);
+            currentPlayer.updateState(hands[nextPlayer], piles);
+            selectedPileIndex = currentPlayer.getPile();
             selected = currentPlayer.getBestCard();
 
             if (selected.isPresent()) {
-                selectedPileIndex = currentPlayer.getPile();
                 setStatusText("Selected: " + canonical(selected.get()) + ". Player" + nextPlayer + " select a pile to play the card.");
+                /*if (humanPlayers[nextPlayer]) {
+                    waitForPileSelection();
+                } else {
+                    selectRandomPile();
+                }*/
                 System.out.println("Player " + nextPlayer + " plays " + canonical(selected.get()) + " on pile " + selectedPileIndex);
                 selected.get().setVerso(false);
                 selected.get().transfer(piles[selectedPileIndex], true); // transfer to pile (includes graphic effect)
                 rankUpdater(piles);
 
+                // Update the state of every player to reflect move change
+                for (int j=0; j<nbPlayers; j++) {
+                    playerList.get(j).updateState(hands[j], piles);
+                }
             } else {
                 setStatusText("Pass.");
             }
-            // Update the state of every player to reflect move change
-            updatePlayers();
-
             nextPlayer++;
             remainingTurns--;
         }
@@ -355,12 +369,6 @@
         delay(watchingTime);
     }
 
-    private void updatePlayers(){
-        for (int j=0; j<nbPlayers; j++) {
-            playerList.get(j).updateState(hands[j], piles);
-        }
-    }
-
     public void rankUpdater(Hand[] piles){
         ArrayList<int[]> bothRanks;
         bothRanks = pileCalculator.updatePileRanks(piles);
@@ -401,7 +409,7 @@
         Properties properties;
 
         if (args == null || args.length == 0) {
-            properties = PropertiesLoader.loadPropertiesFile("properties/onlysmart.properties");
+            properties = PropertiesLoader.loadPropertiesFile("properties/smart.properties");
         } else {
             properties = PropertiesLoader.loadPropertiesFile(args[0]);
         }
Index: properties/smart.properties
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># Seed\r\nseed=30006\r\n# players\r\nplayers.0=human\r\nplayers.1=smart\r\nplayers.2=simple\r\nplayers.3=simple
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>ISO-8859-1
===================================================================
diff --git a/properties/smart.properties b/properties/smart.properties
--- a/properties/smart.properties	(revision f60b451f93982f613df0b4dd79b33b4c8de814cb)
+++ b/properties/smart.properties	(date 1667031779581)
@@ -1,7 +1,7 @@
 # Seed
 seed=30006
 # players
-players.0=human
+players.0=simple
 players.1=smart
 players.2=simple
-players.3=simple
\ No newline at end of file
+players.3=smart
\ No newline at end of file
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"ChangeListManager\">\n    <list default=\"true\" id=\"bc72c28b-5467-4e73-b697-1627d65b1357\" name=\"Changes\" comment=\"\">\n      <change afterPath=\"$PROJECT_DIR$/src/thrones/game/GameRenderer.java\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/src/thrones/game/GameOfThrones.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/thrones/game/GameOfThrones.java\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/src/thrones/game/PileHandler.java\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/src/thrones/game/PileCalculator.java\" afterDir=\"false\" />\n      <change beforePath=\"$PROJECT_DIR$/src/thrones/game/RenderingFacade.java\" beforeDir=\"false\" />\n    </list>\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\n  </component>\n  <component name=\"FileTemplateManagerImpl\">\n    <option name=\"RECENT_TEMPLATES\">\n      <list>\n        <option value=\"Class\" />\n      </list>\n    </option>\n  </component>\n  <component name=\"Git.Settings\">\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\n  </component>\n  <component name=\"MarkdownSettingsMigration\">\n    <option name=\"stateVersion\" value=\"1\" />\n  </component>\n  <component name=\"ProjectId\" id=\"2GfJPcrDFBpyQuBxANSfmdY6IOE\" />\n  <component name=\"ProjectViewState\">\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\n    <option name=\"showLibraryContents\" value=\"true\" />\n  </component>\n  <component name=\"PropertiesComponent\">{\n  &quot;keyToString&quot;: {\n    &quot;RunOnceActivity.OpenProjectViewOnStart&quot;: &quot;true&quot;,\n    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,\n    &quot;SHARE_PROJECT_CONFIGURATION_FILES&quot;: &quot;true&quot;,\n    &quot;jdk.selected.JAVA_MODULE&quot;: &quot;17&quot;,\n    &quot;project.structure.last.edited&quot;: &quot;Modules&quot;,\n    &quot;project.structure.proportion&quot;: &quot;0.14648438&quot;,\n    &quot;project.structure.side.proportion&quot;: &quot;0.2&quot;\n  }\n}</component>\n  <component name=\"RunManager\">\n    <configuration name=\"GameOfThrones\" type=\"Application\" factoryName=\"Application\" nameIsGenerated=\"true\">\n      <option name=\"ALTERNATIVE_JRE_PATH\" value=\"17\" />\n      <option name=\"ALTERNATIVE_JRE_PATH_ENABLED\" value=\"true\" />\n      <option name=\"MAIN_CLASS_NAME\" value=\"thrones.game.GameOfThrones\" />\n      <module name=\"SWEN30006_Assignment_2\" />\n      <extension name=\"coverage\">\n        <pattern>\n          <option name=\"PATTERN\" value=\"thrones.game.*\" />\n          <option name=\"ENABLED\" value=\"true\" />\n        </pattern>\n      </extension>\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration default=\"true\" type=\"JetRunConfigurationType\">\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n    <configuration default=\"true\" type=\"KotlinStandaloneScriptRunConfigurationType\">\n      <option name=\"filePath\" />\n      <method v=\"2\">\n        <option name=\"Make\" enabled=\"true\" />\n      </method>\n    </configuration>\n  </component>\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\n  <component name=\"TaskManager\">\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\n      <changelist id=\"bc72c28b-5467-4e73-b697-1627d65b1357\" name=\"Changes\" comment=\"\" />\n      <created>1666773681486</created>\n      <option name=\"number\" value=\"Default\" />\n      <option name=\"presentableId\" value=\"Default\" />\n      <updated>1666773681486</updated>\n    </task>\n    <servers />\n  </component>\n  <component name=\"Vcs.Log.Tabs.Properties\">\n    <option name=\"TAB_STATES\">\n      <map>\n        <entry key=\"MAIN\">\n          <value>\n            <State />\n          </value>\n        </entry>\n      </map>\n    </option>\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision f60b451f93982f613df0b4dd79b33b4c8de814cb)
+++ b/.idea/workspace.xml	(date 1667032136297)
@@ -2,11 +2,11 @@
 <project version="4">
   <component name="ChangeListManager">
     <list default="true" id="bc72c28b-5467-4e73-b697-1627d65b1357" name="Changes" comment="">
-      <change afterPath="$PROJECT_DIR$/src/thrones/game/GameRenderer.java" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/properties/smart.properties" beforeDir="false" afterPath="$PROJECT_DIR$/properties/smart.properties" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/thrones/game/BattleHandler.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/thrones/game/BattleHandler.java" afterDir="false" />
       <change beforePath="$PROJECT_DIR$/src/thrones/game/GameOfThrones.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/thrones/game/GameOfThrones.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/thrones/game/PileHandler.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/thrones/game/PileCalculator.java" afterDir="false" />
-      <change beforePath="$PROJECT_DIR$/src/thrones/game/RenderingFacade.java" beforeDir="false" />
+      <change beforePath="$PROJECT_DIR$/src/thrones/game/GameRenderer.java" beforeDir="false" afterPath="$PROJECT_DIR$/src/thrones/game/GameRenderer.java" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
Index: src/thrones/game/BattleHandler.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package thrones.game;\nimport ch.aplu.jcardgame.Hand;\n\n/**\n * Simple class that handles the battling of piles and prints results to the console\n */\n\npublic class BattleHandler {\n\n    private final static int ATTACK_RANK_INDEX = 0;\n    private final static int DEFENCE_RANK_INDEX = 1;\n    private final static int CHARACTER_CARD = 0;\n    private final static int PLAYER_ZERO = 0;\n    private final static int PLAYER_ONE = 1;\n    private String character0Result;\n    private String character1Result;\n\n    public BattleHandler() {}\n\n    // Major method call, used to execute battle sequence\n    public int[] battle(int[] pile0Ranks, int[] pile1Ranks, int[] scores, Hand[] piles) {\n        GameOfThrones.Rank pile0CharacterRank = (GameOfThrones.Rank) piles[PLAYER_ZERO].getCardList().get(CHARACTER_CARD).getRank();\n        GameOfThrones.Rank pile1CharacterRank = (GameOfThrones.Rank) piles[PLAYER_ONE].getCardList().get(CHARACTER_CARD).getRank();\n        String character0Result;\n        String character1Result;\n\n        if (pile0Ranks[ATTACK_RANK_INDEX] > pile1Ranks[DEFENCE_RANK_INDEX]) {\n            scores[0] += pile1CharacterRank.getRankValue();\n            scores[2] += pile1CharacterRank.getRankValue();\n            character0Result = \"Character 0 attack on character 1 succeeded.\";\n        } else {\n            scores[1] += pile1CharacterRank.getRankValue();\n            scores[3] += pile1CharacterRank.getRankValue();\n            character0Result = \"Character 0 attack on character 1 failed.\";\n        }\n\n        if (pile1Ranks[ATTACK_RANK_INDEX] > pile0Ranks[DEFENCE_RANK_INDEX]) {\n            scores[1] += pile0CharacterRank.getRankValue();\n            scores[3] += pile0CharacterRank.getRankValue();\n            character1Result = \"Character 1 attack on character 0 succeeded.\";\n        } else {\n            scores[0] += pile0CharacterRank.getRankValue();\n            scores[2] += pile0CharacterRank.getRankValue();\n            character1Result = \"Character 1 attack character 0 failed.\";\n        }\n        //renderingFacade.updateScores();\n        System.out.println(character0Result);\n        System.out.println(character1Result);\n        return scores;\n        //renderingFacade.setStatusText(character0Result, character1Result);\n    }\n\n    public String getCharacter0Result(){\n        return character0Result;\n    }\n    public String getCharacter1Result(){\n        return character1Result;\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/thrones/game/BattleHandler.java b/src/thrones/game/BattleHandler.java
--- a/src/thrones/game/BattleHandler.java	(revision f60b451f93982f613df0b4dd79b33b4c8de814cb)
+++ b/src/thrones/game/BattleHandler.java	(date 1667032132703)
@@ -21,8 +21,6 @@
     public int[] battle(int[] pile0Ranks, int[] pile1Ranks, int[] scores, Hand[] piles) {
         GameOfThrones.Rank pile0CharacterRank = (GameOfThrones.Rank) piles[PLAYER_ZERO].getCardList().get(CHARACTER_CARD).getRank();
         GameOfThrones.Rank pile1CharacterRank = (GameOfThrones.Rank) piles[PLAYER_ONE].getCardList().get(CHARACTER_CARD).getRank();
-        String character0Result;
-        String character1Result;
 
         if (pile0Ranks[ATTACK_RANK_INDEX] > pile1Ranks[DEFENCE_RANK_INDEX]) {
             scores[0] += pile1CharacterRank.getRankValue();
