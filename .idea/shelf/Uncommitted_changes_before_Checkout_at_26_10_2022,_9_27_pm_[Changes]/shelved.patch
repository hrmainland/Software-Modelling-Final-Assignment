Index: src/thrones/game/GameOfThrones.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package thrones.game;\n\n// Oh_Heaven.java\n\nimport ch.aplu.jcardgame.*;\nimport ch.aplu.jgamegrid.*;\n\nimport java.awt.Color;\nimport java.awt.Font;\nimport java.io.FileReader;\nimport java.util.*;\nimport java.util.stream.Collectors;\n\n@SuppressWarnings(\"serial\")\npublic class GameOfThrones extends CardGame {\n\n    enum GoTSuit { CHARACTER, DEFENCE, ATTACK, MAGIC }\n\n    public enum Suit {\n        SPADES(GoTSuit.DEFENCE),\n        HEARTS(GoTSuit.CHARACTER),\n        DIAMONDS(GoTSuit.MAGIC),\n        CLUBS(GoTSuit.ATTACK);\n\n        Suit(GoTSuit gotsuit) {\n            this.gotsuit = gotsuit;\n        }\n        private final GoTSuit gotsuit;\n\n        public boolean isDefence(){ return gotsuit == GoTSuit.DEFENCE; }\n\n        public boolean isAttack(){ return gotsuit == GoTSuit.ATTACK; }\n\n        public boolean isCharacter(){ return gotsuit == GoTSuit.CHARACTER; }\n\n        public boolean isMagic(){ return gotsuit == GoTSuit.MAGIC; }\n    }\n\n    public enum Rank {\n        // Reverse order of rank importance (see rankGreater() below)\n        // Order of cards is tied to card images\n        ACE(1),\n        KING(10),\n        QUEEN(10),\n        JACK(10),\n        TEN(10),\n        NINE(9),\n        EIGHT(8),\n        SEVEN(7),\n        SIX(6),\n        FIVE(5),\n        FOUR(4),\n        THREE(3),\n        TWO(2);\n        Rank(int rankValue) {\n            this.rankValue = rankValue;\n        }\n        private final int rankValue;\n        public int getRankValue() {\n            return rankValue;\n        }\n    }\n\n    /*\n    Canonical String representations of Suit, Rank, Card, and Hand\n    */\n    String canonical(Suit s) { return s.toString().substring(0, 1); }\n\n    String canonical(Rank r) {\n        switch (r) {\n            case ACE: case KING: case QUEEN: case JACK: case TEN:\n                return r.toString().substring(0, 1);\n            default:\n                return String.valueOf(r.getRankValue());\n        }\n    }\n\n    String canonical(Card c) { return canonical((Rank) c.getRank()) + canonical((Suit) c.getSuit()); }\n\n    String canonical(Hand h) {\n        return \"[\" + h.getCardList().stream().map(this::canonical).collect(Collectors.joining(\",\")) + \"]\";\n    }\n    static public int seed;\n    static Random random;\n\n    // return random Card from Hand\n    public static Card randomCard(Hand hand) {\n        assert !hand.isEmpty() : \" random card from empty hand.\";\n        int x = random.nextInt(hand.getNumberOfCards());\n        return hand.get(x);\n    }\n\n    private void dealingOut(Hand[] hands, int nbPlayers, int nbCardsPerPlayer) {\n        Hand pack = deck.toHand(false);\n        assert pack.getNumberOfCards() == 52 : \" Starting pack is not 52 cards.\";\n        // Remove 4 Aces\n        List<Card> aceCards = pack.getCardsWithRank(Rank.ACE);\n        for (Card card : aceCards) {\n            card.removeFromHand(false);\n        }\n        assert pack.getNumberOfCards() == 48 : \" Pack without aces is not 48 cards.\";\n        // Give each player 3 heart cards\n        for (int i = 0; i < nbPlayers; i++) {\n            for (int j = 0; j < 3; j++) {\n                List<Card> heartCards = pack.getCardsWithSuit(Suit.HEARTS);\n                int x = random.nextInt(heartCards.size());\n                Card randomCard = heartCards.get(x);\n                randomCard.removeFromHand(false);\n                hands[i].insert(randomCard, false);\n            }\n        }\n        assert pack.getNumberOfCards() == 36 : \" Pack without aces and hearts is not 36 cards.\";\n        // Give each player 9 of the remaining cards\n        for (int i = 0; i < nbCardsPerPlayer; i++) {\n            for (int j = 0; j < nbPlayers; j++) {\n                assert !pack.isEmpty() : \" Pack has prematurely run out of cards.\";\n                Card dealt = randomCard(pack);\n                dealt.removeFromHand(false);\n                hands[j].insert(dealt, false);\n            }\n        }\n        for (int j = 0; j < nbPlayers; j++) {\n            assert hands[j].getNumberOfCards() == 12 : \" Hand does not have twelve cards.\";\n        }\n    }\n\n    private final String version = \"1.0\";\n    public final int nbPlayers = 4;\n    public final int nbStartCards = 9;\n\tpublic final int nbPlays = 6;\n\tpublic final int nbRounds = 3;\n    private final int handWidth = 400;\n    private final int pileWidth = 40;\n    private Deck deck = new Deck(Suit.values(), Rank.values(), \"cover\");\n    private final Location[] handLocations = {\n            new Location(350, 625),\n            new Location(75, 350),\n            new Location(350, 75),\n            new Location(625, 350)\n    };\n\n    private final Location[] scoreLocations = {\n            new Location(575, 675),\n            new Location(25, 575),\n            new Location(25, 25),\n            new Location(575, 125)\n    };\n    private final Location[] pileLocations = {\n            new Location(350, 280),\n            new Location(350, 430)\n    };\n    private final Location[] pileStatusLocations = {\n            new Location(250, 200),\n            new Location(250, 520)\n    };\n\n    private Actor[] pileTextActors = { null, null };\n    private Actor[] scoreActors = {null, null, null, null};\n    private final int watchingTime = 5000;\n    private Hand[] hands;\n    private Hand[] piles;\n    private final String[] playerTeams = { \"[Players 0 & 2]\", \"[Players 1 & 3]\"};\n    private int nextStartingPlayer = random.nextInt(nbPlayers);\n\n    private int[] scores = new int[nbPlayers];\n\n    Font bigFont = new Font(\"Arial\", Font.BOLD, 36);\n    Font smallFont = new Font(\"Arial\", Font.PLAIN, 10);\n\n    // boolean[] humanPlayers = { true, false, false, false};\n    boolean[] humanPlayers = { false, false, false, false};\n\n\n    private void initScore() {\n        for (int i = 0; i < nbPlayers; i++) {\n             scores[i] = 0;\n            String text = \"P\" + i + \"-0\";\n            scoreActors[i] = new TextActor(text, Color.WHITE, bgColor, bigFont);\n            addActor(scoreActors[i], scoreLocations[i]);\n        }\n\n        String text = \"Attack: 0 - Defence: 0\";\n        for (int i = 0; i < pileTextActors.length; i++) {\n            pileTextActors[i] = new TextActor(text, Color.WHITE, bgColor, smallFont);\n            addActor(pileTextActors[i], pileStatusLocations[i]);\n        }\n    }\n\n    private void updateScore(int player) {\n        removeActor(scoreActors[player]);\n        String text = \"P\" + player + \"-\" + scores[player];\n        scoreActors[player] = new TextActor(text, Color.WHITE, bgColor, bigFont);\n        addActor(scoreActors[player], scoreLocations[player]);\n    }\n\n    private void updateScores() {\n        for (int i = 0; i < nbPlayers; i++) {\n            updateScore(i);\n        }\n        System.out.println(playerTeams[0] + \" score = \" + scores[0] + \"; \" + playerTeams[1] + \" score = \" + scores[1]);\n    }\n\n    private Optional<Card> selected;\n    private final int NON_SELECTION_VALUE = -1;\n    private int selectedPileIndex = NON_SELECTION_VALUE;\n    private final int UNDEFINED_INDEX = -1;\n    private final int ATTACK_RANK_INDEX = 0;\n    private final int DEFENCE_RANK_INDEX = 1;\n    private void setupGame() {\n        hands = new Hand[nbPlayers];\n        for (int i = 0; i < nbPlayers; i++) {\n            hands[i] = new Hand(deck);\n        }\n        dealingOut(hands, nbPlayers, nbStartCards);\n\n        for (int i = 0; i < nbPlayers; i++) {\n            hands[i].sort(Hand.SortType.SUITPRIORITY, true);\n            System.out.println(\"hands[\" + i + \"]: \" + canonical(hands[i]));\n        }\n\n        for (final Hand currentHand : hands) {\n            // Set up human player for interaction\n            currentHand.addCardListener(new CardAdapter() {\n                public void leftDoubleClicked(Card card) {\n                    selected = Optional.of(card);\n                    currentHand.setTouchEnabled(false);\n                }\n                public void rightClicked(Card card) {\n                    selected = Optional.empty(); // Don't care which card we right-clicked for player to pass\n                    currentHand.setTouchEnabled(false);\n                }\n            });\n        }\n        // graphics\n        RowLayout[] layouts = new RowLayout[nbPlayers];\n        for (int i = 0; i < nbPlayers; i++) {\n            layouts[i] = new RowLayout(handLocations[i], handWidth);\n            layouts[i].setRotationAngle(90 * i);\n            hands[i].setView(this, layouts[i]);\n            hands[i].draw();\n        }\n        // End graphics\n    }\n\n    private void resetPile() {\n        if (piles != null) {\n            for (Hand pile : piles) {\n                pile.removeAll(true);\n            }\n        }\n        piles = new Hand[2];\n        for (int i = 0; i < 2; i++) {\n            piles[i] = new Hand(deck);\n            piles[i].setView(this, new RowLayout(pileLocations[i], 8 * pileWidth));\n            piles[i].draw();\n            final Hand currentPile = piles[i];\n            final int pileIndex = i;\n            piles[i].addCardListener(new CardAdapter() {\n                public void leftClicked(Card card) {\n                    selectedPileIndex = pileIndex;\n                    currentPile.setTouchEnabled(false);\n                }\n            });\n        }\n\n        updatePileRanks();\n    }\n\n    private void pickACorrectSuit(int playerIndex, boolean isCharacter) {\n        Hand currentHand = hands[playerIndex];\n        List<Card> shortListCards = new ArrayList<>();\n        for (int i = 0; i < currentHand.getCardList().size(); i++) {\n            Card card = currentHand.getCardList().get(i);\n            Suit suit = (Suit) card.getSuit();\n            if (suit.isCharacter() == isCharacter) {\n                shortListCards.add(card);\n            }\n        }\n        if (shortListCards.isEmpty() || !isCharacter && random.nextInt(3) == 0) {\n            selected = Optional.empty();\n        } else {\n            selected = Optional.of(shortListCards.get(random.nextInt(shortListCards.size())));\n        }\n    }\n\n    private void selectRandomPile() {\n        selectedPileIndex = random.nextInt(2);\n    }\n\n    private void waitForCorrectSuit(int playerIndex, boolean isCharacter) {\n        if (hands[playerIndex].isEmpty()) {\n            selected = Optional.empty();\n        } else {\n            selected = null;\n            hands[playerIndex].setTouchEnabled(true);\n            do {\n                if (selected == null) {\n                    delay(100);\n                    continue;\n                }\n                Suit suit = selected.isPresent() ? (Suit) selected.get().getSuit() : null;\n                if (isCharacter && suit != null && suit.isCharacter() ||         // If we want character, can't pass and suit must be right\n                        !isCharacter && (suit == null || !suit.isCharacter())) { // If we don't want character, can pass or suit must not be character\n                    // if (suit != null && suit.isCharacter() == isCharacter) {\n                    break;\n                } else {\n                    selected = null;\n                    hands[playerIndex].setTouchEnabled(true);\n                }\n                delay(100);\n            } while (true);\n        }\n    }\n\n    private void waitForPileSelection() {\n        selectedPileIndex = NON_SELECTION_VALUE;\n        for (Hand pile : piles) {\n            pile.setTouchEnabled(true);\n        }\n        while(selectedPileIndex == NON_SELECTION_VALUE) {\n            delay(100);\n        }\n        for (Hand pile : piles) {\n            pile.setTouchEnabled(false);\n        }\n    }\n\n    private int[] calculatePileRanks(int pileIndex) {\n        Hand currentPile = piles[pileIndex];\n        int i = currentPile.isEmpty() ? 0 : ((Rank) currentPile.get(0).getRank()).getRankValue();\n        return new int[] { i, i };\n    }\n\n    private void updatePileRankState(int pileIndex, int attackRank, int defenceRank) {\n        TextActor currentPile = (TextActor) pileTextActors[pileIndex];\n        removeActor(currentPile);\n        String text = playerTeams[pileIndex] + \" Attack: \" + attackRank + \" - Defence: \" + defenceRank;\n        pileTextActors[pileIndex] = new TextActor(text, Color.WHITE, bgColor, smallFont);\n        addActor(pileTextActors[pileIndex], pileStatusLocations[pileIndex]);\n    }\n\n    private void updatePileRanks() {\n        for (int j = 0; j < piles.length; j++) {\n            int[] ranks = calculatePileRanks(j);\n            updatePileRankState(j, ranks[ATTACK_RANK_INDEX], ranks[DEFENCE_RANK_INDEX]);\n        }\n    }\n\n    private int getPlayerIndex(int index) {\n        return index % nbPlayers;\n    }\n\n    private void executeAPlay() {\n        resetPile();\n\n        nextStartingPlayer = getPlayerIndex(nextStartingPlayer);\n        if (hands[nextStartingPlayer].getNumberOfCardsWithSuit(Suit.HEARTS) == 0)\n            nextStartingPlayer = getPlayerIndex(nextStartingPlayer + 1);\n        assert hands[nextStartingPlayer].getNumberOfCardsWithSuit(Suit.HEARTS) != 0 : \" Starting player has no hearts.\";\n\n        // 1: play the first 2 hearts\n        for (int i = 0; i < 2; i++) {\n            int playerIndex = getPlayerIndex(nextStartingPlayer + i);\n            setStatusText(\"Player \" + playerIndex + \" select a Heart card to play\");\n            if (humanPlayers[playerIndex]) {\n                waitForCorrectSuit(playerIndex, true);\n            } else {\n                pickACorrectSuit(playerIndex, true);\n            }\n\n            int pileIndex = playerIndex % 2;\n            assert selected.isPresent() : \" Pass returned on selection of character.\";\n            System.out.println(\"Player \" + playerIndex + \" plays \" + canonical(selected.get()) + \" on pile \" + pileIndex);\n            selected.get().setVerso(false);\n            selected.get().transfer(piles[pileIndex], true); // transfer to pile (includes graphic effect)\n            updatePileRanks();\n        }\n\n        // 2: play the remaining nbPlayers * nbRounds - 2\n        int remainingTurns = nbPlayers * nbRounds - 2;\n        int nextPlayer = nextStartingPlayer + 2;\n\n        while(remainingTurns > 0) {\n            nextPlayer = getPlayerIndex(nextPlayer);\n            setStatusText(\"Player\" + nextPlayer + \" select a non-Heart card to play.\");\n            if (humanPlayers[nextPlayer]) {\n                waitForCorrectSuit(nextPlayer, false);\n            } else {\n                pickACorrectSuit(nextPlayer, false);\n            }\n\n            if (selected.isPresent()) {\n                setStatusText(\"Selected: \" + canonical(selected.get()) + \". Player\" + nextPlayer + \" select a pile to play the card.\");\n                if (humanPlayers[nextPlayer]) {\n                    waitForPileSelection();\n                } else {\n                    selectRandomPile();\n                }\n                System.out.println(\"Player \" + nextPlayer + \" plays \" + canonical(selected.get()) + \" on pile \" + selectedPileIndex);\n                selected.get().setVerso(false);\n                selected.get().transfer(piles[selectedPileIndex], true); // transfer to pile (includes graphic effect)\n                updatePileRanks();\n            } else {\n                setStatusText(\"Pass.\");\n            }\n            nextPlayer++;\n            remainingTurns--;\n        }\n\n        // 3: calculate winning & update scores for players\n        updatePileRanks();\n        int[] pile0Ranks = calculatePileRanks(0);\n        int[] pile1Ranks = calculatePileRanks(1);\n        System.out.println(\"piles[0]: \" + canonical(piles[0]));\n        System.out.println(\"piles[0] is \" + \"Attack: \" + pile0Ranks[ATTACK_RANK_INDEX] + \" - Defence: \" + pile0Ranks[DEFENCE_RANK_INDEX]);\n        System.out.println(\"piles[1]: \" + canonical(piles[1]));\n        System.out.println(\"piles[1] is \" + \"Attack: \" + pile1Ranks[ATTACK_RANK_INDEX] + \" - Defence: \" + pile1Ranks[DEFENCE_RANK_INDEX]);\n        Rank pile0CharacterRank = (Rank) piles[0].getCardList().get(0).getRank();\n        Rank pile1CharacterRank = (Rank) piles[1].getCardList().get(0).getRank();\n        String character0Result;\n        String character1Result;\n\n        if (pile0Ranks[ATTACK_RANK_INDEX] > pile1Ranks[DEFENCE_RANK_INDEX]) {\n            scores[0] += pile1CharacterRank.getRankValue();\n            scores[2] += pile1CharacterRank.getRankValue();\n            character0Result = \"Character 0 attack on character 1 succeeded.\";\n        } else {\n            scores[1] += pile1CharacterRank.getRankValue();\n            scores[3] += pile1CharacterRank.getRankValue();\n            character0Result = \"Character 0 attack on character 1 failed.\";\n        }\n\n        if (pile1Ranks[ATTACK_RANK_INDEX] > pile0Ranks[DEFENCE_RANK_INDEX]) {\n            scores[1] += pile0CharacterRank.getRankValue();\n            scores[3] += pile0CharacterRank.getRankValue();\n            character1Result = \"Character 1 attack on character 0 succeeded.\";\n        } else {\n            scores[0] += pile0CharacterRank.getRankValue();\n            scores[2] += pile0CharacterRank.getRankValue();\n            character1Result = \"Character 1 attack character 0 failed.\";\n        }\n        updateScores();\n        System.out.println(character0Result);\n        System.out.println(character1Result);\n        setStatusText(character0Result + \" \" + character1Result);\n\n        // 5: discarded all cards on the piles\n        nextStartingPlayer += 1;\n        delay(watchingTime);\n    }\n\n    public GameOfThrones() {\n        super(700, 700, 30);\n\n        setTitle(\"Game of Thrones (V\" + version + \") Constructed for UofM SWEN30006 with JGameGrid (www.aplu.ch)\");\n        setStatusText(\"Initializing...\");\n        initScore();\n\n        setupGame();\n        for (int i = 0; i < nbPlays; i++) {\n            executeAPlay();\n            updateScores();\n        }\n\n        String text;\n        if (scores[0] > scores[1]) {\n            text = \"Players 0 and 2 won.\";\n        } else if (scores[0] == scores[1]) {\n            text = \"All players drew.\";\n        } else {\n            text = \"Players 1 and 3 won.\";\n        }\n        System.out.println(\"Result: \" + text);\n        setStatusText(text);\n\n        refresh();\n    }\n\n    public static void main(String[] args) {\n        // System.out.println(\"Working Directory = \" + System.getProperty(\"user.dir\"));\n        // final Properties properties = new Properties();\n        // properties.setProperty(\"watchingTime\", \"5000\");\n        /*\n        if (args == null || args.length == 0) {\n            //  properties = PropertiesLoader.loadPropertiesFile(\"cribbage.properties\");\n        } else {\n            //  properties = PropertiesLoader.loadPropertiesFile(args[0]);\n        }\n\n        String seedProp = properties.getProperty(\"seed\");  //Seed property\n        if (seedProp != null) { // Use property seed\n\t\t\t  seed = Integer.parseInt(seedProp);\n        } else { // and no property\n\t\t\t  seed = new Random().nextInt(); // so randomise\n        }\n        */\n        GameOfThrones.seed = 130007;\n        System.out.println(\"Seed = \" + seed);\n        GameOfThrones.random = new Random(seed);\n        new GameOfThrones();\n    }\n\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/thrones/game/GameOfThrones.java b/src/thrones/game/GameOfThrones.java
--- a/src/thrones/game/GameOfThrones.java	(revision 649923cd797765416e653b5684d4fcd12791420f)
+++ b/src/thrones/game/GameOfThrones.java	(date 1666778749554)
@@ -328,6 +328,7 @@
     private int[] calculatePileRanks(int pileIndex) {
         Hand currentPile = piles[pileIndex];
         int i = currentPile.isEmpty() ? 0 : ((Rank) currentPile.get(0).getRank()).getRankValue();
+        for (m = 0; m < currentPile)
         return new int[] { i, i };
     }
 
